"""
Writes the parts of the API that are simple: flags, enums, structs.
"""

import re

from codegen.utils import print, blacken, to_snake_case
from codegen.idlparser import get_idl_parser
from codegen.files import file_cache


ref_pattern = re.compile(r"\W((GPU|flags\.|enums\.|structs\.)\w+?)\W", re.MULTILINE)


def resolve_crossrefs(text):
    # Similar code as in docs/conf.py
    text += " "
    i2 = 0
    while True:
        m = ref_pattern.search(text, i2)
        if not m:
            break
        i1, i2 = m.start(1), m.end(1)
        prefix = m.group(2)
        ref_indicator = ":obj:" if prefix.lower() == prefix else ":class:"
        name = m.group(1)
        if name.startswith("structs."):
            link = name.split(".")[1]
        else:
            link = "wgpu." + name
        insertion = f"{ref_indicator}`{name} <{link}>`"
        text = text[:i1] + insertion + text[i2:]
        i2 += len(insertion) - len(name)
    return text.rstrip()


flags_preamble = '''
"""
Flags are bitmasks; zero or multiple fields can be set at the same time.
These flags are also available in the root wgpu namespace.
"""

# THIS CODE IS AUTOGENERATED - DO NOT EDIT

_use_sphinx_repr = False

class Flags:

    def __init__(self, name, **kwargs):
        self._name = name
        for key, val in kwargs.items():
            setattr(self, key, val)

    def __iter__(self):
        return iter([key for key in dir(self) if not key.startswith("_")])

    def __repr__(self):
        if _use_sphinx_repr:  # no-cover
            return ""
        options = ", ".join(self)
        return f"<{self.__class__.__name__} {self._name}: {options}>"

'''.lstrip()


def write_flags():
    idl = get_idl_parser()
    n = len(idl.flags)
    # Preamble
    pylines = [flags_preamble]
    pylines.append(f"# There are {n} flags\n")
    for name, d in idl.flags.items():
        # Object-docstring as a comment
        for key, val in d.items():
            pylines.append(f'#: * "{key}" ({val})')
        # Generate Code
        pylines.append(f'{name} = Flags(\n    "{name}",')
        for key, val in d.items():
            pylines.append(f"    {key}={val!r},")
        pylines.append(")\n")
    # Write
    code = blacken("\n".join(pylines))
    file_cache.write("flags.py", code)
    print(f"Wrote {n} flags to flags.py")


enums_preamble = '''
"""
Enums are choices; exactly one field must be selected.
These enums are also available in the root wgpu namespace.
"""

# THIS CODE IS AUTOGENERATED - DO NOT EDIT

_use_sphinx_repr = False

class Enum:

    def __init__(self, name, **kwargs):
        self._name = name
        for key, val in kwargs.items():
            setattr(self, key, val)

    def __iter__(self):
        return iter(
            [getattr(self, key) for key in dir(self) if not key.startswith("_")]
        )

    def __repr__(self):
        if _use_sphinx_repr:  # no-cover
            return ""
        options = ", ".join(f"'{x}'" for x in self)
        return f"<{self.__class__.__name__} {self._name}: {options}>"

'''.lstrip()


def write_enums():
    idl = get_idl_parser()
    n = len(idl.enums)
    # Preamble
    pylines = [enums_preamble]
    pylines.append(f"# There are {n} enums\n")
    for name, d in idl.enums.items():
        # Object-docstring as a comment
        for key, val in d.items():
            pylines.append(f'#: * "{key}"')
        # Generate Code
        pylines.append(f'{name} = Enum(\n    "{name}",')
        for key, val in d.items():
            pylines.append(f'    {key}="{val}",')
        pylines.append(")\n")
    # Write
    code = blacken("\n".join(pylines))
    file_cache.write("enums.py", code)
    print(f"Wrote {n} enums to enums.py")


structs_preamble = '''
"""
The sructs in wgpu-py are represented as Python dictionaries.
Fields that have default values (as indicated below) may be omitted.
"""

# THIS CODE IS AUTOGENERATED - DO NOT EDIT

_use_sphinx_repr = False


class Struct:
    def __init__(self, name, **kwargs):
        self._name = name
        for key, val in kwargs.items():
            setattr(self, key, val)

    def __iter__(self):
        return iter(
            [key for key in dir(self) if not key.startswith("_")]
        )

    def __repr__(self):
        if _use_sphinx_repr:  # no-cover
            return ""
        options = ", ".join(f"'{x}'" for x in self)
        return f"<{self.__class__.__name__} {self._name}: {options}>"

'''.lstrip()


def write_structs():
    ignore = ["ImageCopyTextureTagged"]
    idl = get_idl_parser()
    n = len(idl.structs)
    # Preamble
    pylines = [structs_preamble]
    pylines.append(f"# There are {n} structs\n")
    for name, d in idl.structs.items():
        if name in ignore:
            continue
        # Object-docstring as a comment
        for field in d.values():
            tp = idl.resolve_type(field.typename).strip("'")
            if field.default is not None:
                pylines.append(
                    resolve_crossrefs(f"#: * {field.name} :: {tp} = {field.default}")
                )
            else:
                pylines.append(resolve_crossrefs(f"#: * {field.name} :: {tp}"))
        # Generate Code
        pylines.append(f'{name} = Struct(\n    "{name}",')
        for field in d.values():
            key = to_snake_case(field.name)
            val = idl.resolve_type(field.typename)
            if not val.startswith(("'", '"')):
                val = f"'{val}'"
            pylines.append(f"    {key}={val},")
        pylines.append(")\n")

    # Write
    code = blacken("\n".join(pylines))
    file_cache.write("structs.py", code)
    print(f"Wrote {n} structs to structs.py")
