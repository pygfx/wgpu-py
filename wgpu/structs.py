"""
These structs are defined in ``wgpu.structs``, but are also available from the root wgpu namespace.

The classes below are dataclasses; they are used for typing, (static and
dynamic) autocompletion, and docs. The recommended way to use wgpu structs is to
instantiate these classes, since that results in a code that is readable
and type-checkable. However, structs can also be defined using plain Python
dicts. Their fields are checked at runtime.
"""

# Allow using class names in type annotations, without Ruff triggering F821
from __future__ import annotations

from dataclasses import dataclass
from collections.abc import Mapping

from ._coreutils import ArrayLike, CanvasLike
from . import _classes as classes
from . import flags
from . import enums


class Struct(Mapping):
    # By inherting from Mapping, these structs can be used as kwargs, e.g. ``some_method(**struct)``.

    def __getitem__(self, key):
        return self.__dict__[key]

    def __iter__(self):
        return iter(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def get(self, key, default=None):
        """Get method that returns the default when the acual value is None."""
        # Get the stored value. Note that we don't allow unknown/invalid keys
        val = self.__dict__[key]
        # None means default
        if val is None:
            return default
        return val


# CODE BELOW THIS POINT IS AUTOGENERATED - DO NOT EDIT


# There are 60 structs

__all__ = [
    "BindGroupDescriptor",
    "BindGroupEntry",
    "BindGroupLayoutDescriptor",
    "BindGroupLayoutEntry",
    "BlendComponent",
    "BlendState",
    "BufferBinding",
    "BufferBindingLayout",
    "BufferDescriptor",
    "CanvasConfiguration",
    "CanvasToneMapping",
    "Color",
    "ColorTargetState",
    "CommandBufferDescriptor",
    "CommandEncoderDescriptor",
    "ComputePassDescriptor",
    "ComputePassTimestampWrites",
    "ComputePipelineDescriptor",
    "CopyExternalImageDestInfo",
    "CopyExternalImageSourceInfo",
    "DepthStencilState",
    "DeviceDescriptor",
    "Extent3D",
    "ExternalTextureBindingLayout",
    "ExternalTextureDescriptor",
    "FragmentState",
    "MultisampleState",
    "Origin2D",
    "Origin3D",
    "PipelineErrorInit",
    "PipelineLayoutDescriptor",
    "PrimitiveState",
    "ProgrammableStage",
    "QuerySetDescriptor",
    "QueueDescriptor",
    "RenderBundleDescriptor",
    "RenderBundleEncoderDescriptor",
    "RenderPassColorAttachment",
    "RenderPassDepthStencilAttachment",
    "RenderPassDescriptor",
    "RenderPassLayout",
    "RenderPassTimestampWrites",
    "RenderPipelineDescriptor",
    "RequestAdapterOptions",
    "SamplerBindingLayout",
    "SamplerDescriptor",
    "ShaderModuleCompilationHint",
    "ShaderModuleDescriptor",
    "StencilFaceState",
    "StorageTextureBindingLayout",
    "TexelCopyBufferInfo",
    "TexelCopyBufferLayout",
    "TexelCopyTextureInfo",
    "TextureBindingLayout",
    "TextureDescriptor",
    "TextureViewDescriptor",
    "UncapturedErrorEventInit",
    "VertexAttribute",
    "VertexBufferLayout",
    "VertexState",
]


@dataclass(kw_only=True)
class RequestAdapterOptions(Struct):
    #:
    feature_level: str = "core"
    #: :obj:`enums.PowerPreference <wgpu.enums.PowerPreference>`
    power_preference: enums.PowerPreferenceEnum | None = None
    #:
    force_fallback_adapter: bool = False
    #:
    xr_compatible: bool = False


RequestAdapterOptionsStruct = RequestAdapterOptions | dict


@dataclass(kw_only=True)
class DeviceDescriptor(Struct):
    #:
    label: str = ""
    #: list[:obj:`enums.FeatureName <wgpu.enums.FeatureName>`]
    required_features: list[enums.FeatureNameEnum] | None = None
    #:
    required_limits: dict[str, int | None] | None = None
    #:
    default_queue: QueueDescriptorStruct | None = None


DeviceDescriptorStruct = DeviceDescriptor | dict


@dataclass(kw_only=True)
class BufferDescriptor(Struct):
    #:
    label: str = ""
    #:
    size: int
    #: :obj:`flags.BufferUsage <wgpu.flags.BufferUsage>`
    usage: flags.BufferUsageFlags
    #:
    mapped_at_creation: bool = False


BufferDescriptorStruct = BufferDescriptor | dict


@dataclass(kw_only=True)
class TextureDescriptor(Struct):
    #:
    label: str = ""
    #:
    size: tuple[int, int, int] | Extent3DStruct
    #:
    mip_level_count: int = 1
    #:
    sample_count: int = 1
    #: :obj:`enums.TextureDimension <wgpu.enums.TextureDimension>`
    dimension: enums.TextureDimensionEnum = "2d"
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    format: enums.TextureFormatEnum
    #: :obj:`flags.TextureUsage <wgpu.flags.TextureUsage>`
    usage: flags.TextureUsageFlags
    #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    view_formats: list[enums.TextureFormatEnum] | None = None


TextureDescriptorStruct = TextureDescriptor | dict


@dataclass(kw_only=True)
class TextureViewDescriptor(Struct):
    #:
    label: str = ""
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    format: enums.TextureFormatEnum | None = None
    #: :obj:`enums.TextureViewDimension <wgpu.enums.TextureViewDimension>`
    dimension: enums.TextureViewDimensionEnum | None = None
    #: :obj:`flags.TextureUsage <wgpu.flags.TextureUsage>`
    usage: flags.TextureUsageFlags = 0
    #: :obj:`enums.TextureAspect <wgpu.enums.TextureAspect>`
    aspect: enums.TextureAspectEnum = "all"
    #:
    base_mip_level: int = 0
    #:
    mip_level_count: int | None = None
    #:
    base_array_layer: int = 0
    #:
    array_layer_count: int | None = None


TextureViewDescriptorStruct = TextureViewDescriptor | dict


@dataclass(kw_only=True)
class ExternalTextureDescriptor(Struct):
    #:
    label: str = ""
    #:
    source: ArrayLike | object
    #:
    color_space: str = "srgb"


ExternalTextureDescriptorStruct = ExternalTextureDescriptor | dict


@dataclass(kw_only=True)
class SamplerDescriptor(Struct):
    #:
    label: str = ""
    #: :obj:`enums.AddressMode <wgpu.enums.AddressMode>`
    address_mode_u: enums.AddressModeEnum = "clamp-to-edge"
    #: :obj:`enums.AddressMode <wgpu.enums.AddressMode>`
    address_mode_v: enums.AddressModeEnum = "clamp-to-edge"
    #: :obj:`enums.AddressMode <wgpu.enums.AddressMode>`
    address_mode_w: enums.AddressModeEnum = "clamp-to-edge"
    #: :obj:`enums.FilterMode <wgpu.enums.FilterMode>`
    mag_filter: enums.FilterModeEnum = "nearest"
    #: :obj:`enums.FilterMode <wgpu.enums.FilterMode>`
    min_filter: enums.FilterModeEnum = "nearest"
    #: :obj:`enums.MipmapFilterMode <wgpu.enums.MipmapFilterMode>`
    mipmap_filter: enums.MipmapFilterModeEnum = "nearest"
    #:
    lod_min_clamp: float = 0
    #:
    lod_max_clamp: float = 32
    #: :obj:`enums.CompareFunction <wgpu.enums.CompareFunction>`
    compare: enums.CompareFunctionEnum | None = None
    #:
    max_anisotropy: int = 1


SamplerDescriptorStruct = SamplerDescriptor | dict


@dataclass(kw_only=True)
class BindGroupLayoutDescriptor(Struct):
    #:
    label: str = ""
    #:
    entries: list[BindGroupLayoutEntryStruct]


BindGroupLayoutDescriptorStruct = BindGroupLayoutDescriptor | dict


@dataclass(kw_only=True)
class BindGroupLayoutEntry(Struct):
    #:
    binding: int
    #: :obj:`flags.ShaderStage <wgpu.flags.ShaderStage>`
    visibility: flags.ShaderStageFlags
    #:
    buffer: BufferBindingLayoutStruct | None = None
    #:
    sampler: SamplerBindingLayoutStruct | None = None
    #:
    texture: TextureBindingLayoutStruct | None = None
    #:
    storage_texture: StorageTextureBindingLayoutStruct | None = None
    #:
    external_texture: ExternalTextureBindingLayoutStruct | None = None


BindGroupLayoutEntryStruct = BindGroupLayoutEntry | dict


@dataclass(kw_only=True)
class BufferBindingLayout(Struct):
    #: :obj:`enums.BufferBindingType <wgpu.enums.BufferBindingType>`
    type: enums.BufferBindingTypeEnum = "uniform"
    #:
    has_dynamic_offset: bool = False
    #:
    min_binding_size: int = 0


BufferBindingLayoutStruct = BufferBindingLayout | dict


@dataclass(kw_only=True)
class SamplerBindingLayout(Struct):
    #: :obj:`enums.SamplerBindingType <wgpu.enums.SamplerBindingType>`
    type: enums.SamplerBindingTypeEnum = "filtering"


SamplerBindingLayoutStruct = SamplerBindingLayout | dict


@dataclass(kw_only=True)
class TextureBindingLayout(Struct):
    #: :obj:`enums.TextureSampleType <wgpu.enums.TextureSampleType>`
    sample_type: enums.TextureSampleTypeEnum = "float"
    #: :obj:`enums.TextureViewDimension <wgpu.enums.TextureViewDimension>`
    view_dimension: enums.TextureViewDimensionEnum = "2d"
    #:
    multisampled: bool = False


TextureBindingLayoutStruct = TextureBindingLayout | dict


@dataclass(kw_only=True)
class StorageTextureBindingLayout(Struct):
    #: :obj:`enums.StorageTextureAccess <wgpu.enums.StorageTextureAccess>`
    access: enums.StorageTextureAccessEnum = "write-only"
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    format: enums.TextureFormatEnum
    #: :obj:`enums.TextureViewDimension <wgpu.enums.TextureViewDimension>`
    view_dimension: enums.TextureViewDimensionEnum = "2d"


StorageTextureBindingLayoutStruct = StorageTextureBindingLayout | dict


@dataclass(kw_only=True)
class ExternalTextureBindingLayout(Struct):
    pass


ExternalTextureBindingLayoutStruct = ExternalTextureBindingLayout | dict


@dataclass(kw_only=True)
class BindGroupDescriptor(Struct):
    #:
    label: str = ""
    #:
    layout: classes.GPUBindGroupLayout
    #:
    entries: list[BindGroupEntryStruct]


BindGroupDescriptorStruct = BindGroupDescriptor | dict


@dataclass(kw_only=True)
class BindGroupEntry(Struct):
    #:
    binding: int
    #:
    resource: (
        classes.GPUBuffer
        | classes.GPUSampler
        | classes.GPUTexture
        | classes.GPUTextureView
        | object
        | BufferBindingStruct
    )


BindGroupEntryStruct = BindGroupEntry | dict


@dataclass(kw_only=True)
class BufferBinding(Struct):
    #:
    buffer: classes.GPUBuffer
    #:
    offset: int = 0
    #:
    size: int | None = None


BufferBindingStruct = BufferBinding | dict


@dataclass(kw_only=True)
class PipelineLayoutDescriptor(Struct):
    #:
    label: str = ""
    #:
    bind_group_layouts: list[classes.GPUBindGroupLayout]


PipelineLayoutDescriptorStruct = PipelineLayoutDescriptor | dict


@dataclass(kw_only=True)
class ShaderModuleDescriptor(Struct):
    #:
    label: str = ""
    #:
    code: str
    #:
    compilation_hints: list[ShaderModuleCompilationHintStruct] | None = None


ShaderModuleDescriptorStruct = ShaderModuleDescriptor | dict


@dataclass(kw_only=True)
class ShaderModuleCompilationHint(Struct):
    #:
    entry_point: str
    #: :class:`GPUPipelineLayout <wgpu.GPUPipelineLayout>` | :obj:`enums.AutoLayoutMode <wgpu.enums.AutoLayoutMode>`
    layout: classes.GPUPipelineLayout | enums.AutoLayoutModeEnum | None = None


ShaderModuleCompilationHintStruct = ShaderModuleCompilationHint | dict


@dataclass(kw_only=True)
class PipelineErrorInit(Struct):
    #: :obj:`enums.PipelineErrorReason <wgpu.enums.PipelineErrorReason>`
    reason: enums.PipelineErrorReasonEnum


PipelineErrorInitStruct = PipelineErrorInit | dict


@dataclass(kw_only=True)
class ProgrammableStage(Struct):
    #:
    module: classes.GPUShaderModule
    #:
    entry_point: str | None = None
    #:
    constants: dict[str, float] | None = None


ProgrammableStageStruct = ProgrammableStage | dict


@dataclass(kw_only=True)
class ComputePipelineDescriptor(Struct):
    #:
    label: str = ""
    #: :class:`GPUPipelineLayout <wgpu.GPUPipelineLayout>` | :obj:`enums.AutoLayoutMode <wgpu.enums.AutoLayoutMode>`
    layout: classes.GPUPipelineLayout | enums.AutoLayoutModeEnum
    #:
    compute: ProgrammableStageStruct


ComputePipelineDescriptorStruct = ComputePipelineDescriptor | dict


@dataclass(kw_only=True)
class RenderPipelineDescriptor(Struct):
    #:
    label: str = ""
    #: :class:`GPUPipelineLayout <wgpu.GPUPipelineLayout>` | :obj:`enums.AutoLayoutMode <wgpu.enums.AutoLayoutMode>`
    layout: classes.GPUPipelineLayout | enums.AutoLayoutModeEnum
    #:
    vertex: VertexStateStruct
    #:
    primitive: PrimitiveStateStruct | None = None
    #:
    depth_stencil: DepthStencilStateStruct | None = None
    #:
    multisample: MultisampleStateStruct | None = None
    #:
    fragment: FragmentStateStruct | None = None


RenderPipelineDescriptorStruct = RenderPipelineDescriptor | dict


@dataclass(kw_only=True)
class PrimitiveState(Struct):
    #: :obj:`enums.PrimitiveTopology <wgpu.enums.PrimitiveTopology>`
    topology: enums.PrimitiveTopologyEnum = "triangle-list"
    #: :obj:`enums.IndexFormat <wgpu.enums.IndexFormat>`
    strip_index_format: enums.IndexFormatEnum | None = None
    #: :obj:`enums.FrontFace <wgpu.enums.FrontFace>`
    front_face: enums.FrontFaceEnum = "ccw"
    #: :obj:`enums.CullMode <wgpu.enums.CullMode>`
    cull_mode: enums.CullModeEnum = "none"
    #:
    unclipped_depth: bool = False


PrimitiveStateStruct = PrimitiveState | dict


@dataclass(kw_only=True)
class MultisampleState(Struct):
    #:
    count: int = 1
    #:
    mask: int = 0xFFFFFFFF
    #:
    alpha_to_coverage_enabled: bool = False


MultisampleStateStruct = MultisampleState | dict


@dataclass(kw_only=True)
class FragmentState(Struct):
    #:
    module: classes.GPUShaderModule
    #:
    entry_point: str | None = None
    #:
    constants: dict[str, float] | None = None
    #:
    targets: list[ColorTargetStateStruct]


FragmentStateStruct = FragmentState | dict


@dataclass(kw_only=True)
class ColorTargetState(Struct):
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    format: enums.TextureFormatEnum
    #:
    blend: BlendStateStruct | None = None
    #: :obj:`flags.ColorWrite <wgpu.flags.ColorWrite>`
    write_mask: flags.ColorWriteFlags = 0xF


ColorTargetStateStruct = ColorTargetState | dict


@dataclass(kw_only=True)
class BlendState(Struct):
    #:
    color: BlendComponentStruct
    #:
    alpha: BlendComponentStruct


BlendStateStruct = BlendState | dict


@dataclass(kw_only=True)
class BlendComponent(Struct):
    #: :obj:`enums.BlendOperation <wgpu.enums.BlendOperation>`
    operation: enums.BlendOperationEnum = "add"
    #: :obj:`enums.BlendFactor <wgpu.enums.BlendFactor>`
    src_factor: enums.BlendFactorEnum = "one"
    #: :obj:`enums.BlendFactor <wgpu.enums.BlendFactor>`
    dst_factor: enums.BlendFactorEnum = "zero"


BlendComponentStruct = BlendComponent | dict


@dataclass(kw_only=True)
class DepthStencilState(Struct):
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    format: enums.TextureFormatEnum
    #:
    depth_write_enabled: bool | None = None
    #: :obj:`enums.CompareFunction <wgpu.enums.CompareFunction>`
    depth_compare: enums.CompareFunctionEnum | None = None
    #:
    stencil_front: StencilFaceStateStruct | None = None
    #:
    stencil_back: StencilFaceStateStruct | None = None
    #:
    stencil_read_mask: int = 0xFFFFFFFF
    #:
    stencil_write_mask: int = 0xFFFFFFFF
    #:
    depth_bias: int = 0
    #:
    depth_bias_slope_scale: float = 0
    #:
    depth_bias_clamp: float = 0


DepthStencilStateStruct = DepthStencilState | dict


@dataclass(kw_only=True)
class StencilFaceState(Struct):
    #: :obj:`enums.CompareFunction <wgpu.enums.CompareFunction>`
    compare: enums.CompareFunctionEnum = "always"
    #: :obj:`enums.StencilOperation <wgpu.enums.StencilOperation>`
    fail_op: enums.StencilOperationEnum = "keep"
    #: :obj:`enums.StencilOperation <wgpu.enums.StencilOperation>`
    depth_fail_op: enums.StencilOperationEnum = "keep"
    #: :obj:`enums.StencilOperation <wgpu.enums.StencilOperation>`
    pass_op: enums.StencilOperationEnum = "keep"


StencilFaceStateStruct = StencilFaceState | dict


@dataclass(kw_only=True)
class VertexState(Struct):
    #:
    module: classes.GPUShaderModule
    #:
    entry_point: str | None = None
    #:
    constants: dict[str, float] | None = None
    #:
    buffers: list[VertexBufferLayoutStruct] | None = None


VertexStateStruct = VertexState | dict


@dataclass(kw_only=True)
class VertexBufferLayout(Struct):
    #:
    array_stride: int
    #: :obj:`enums.VertexStepMode <wgpu.enums.VertexStepMode>`
    step_mode: enums.VertexStepModeEnum = "vertex"
    #:
    attributes: list[VertexAttributeStruct]


VertexBufferLayoutStruct = VertexBufferLayout | dict


@dataclass(kw_only=True)
class VertexAttribute(Struct):
    #: :obj:`enums.VertexFormat <wgpu.enums.VertexFormat>`
    format: enums.VertexFormatEnum
    #:
    offset: int
    #:
    shader_location: int


VertexAttributeStruct = VertexAttribute | dict


@dataclass(kw_only=True)
class TexelCopyBufferLayout(Struct):
    #:
    offset: int = 0
    #:
    bytes_per_row: int | None = None
    #:
    rows_per_image: int | None = None


TexelCopyBufferLayoutStruct = TexelCopyBufferLayout | dict


@dataclass(kw_only=True)
class TexelCopyBufferInfo(Struct):
    #:
    offset: int = 0
    #:
    bytes_per_row: int | None = None
    #:
    rows_per_image: int | None = None
    #:
    buffer: classes.GPUBuffer


TexelCopyBufferInfoStruct = TexelCopyBufferInfo | dict


@dataclass(kw_only=True)
class TexelCopyTextureInfo(Struct):
    #:
    texture: classes.GPUTexture
    #:
    mip_level: int = 0
    #:
    origin: tuple[int, int, int] | Origin3DStruct | None = None
    #: :obj:`enums.TextureAspect <wgpu.enums.TextureAspect>`
    aspect: enums.TextureAspectEnum = "all"


TexelCopyTextureInfoStruct = TexelCopyTextureInfo | dict


@dataclass(kw_only=True)
class CopyExternalImageDestInfo(Struct):
    #:
    texture: classes.GPUTexture
    #:
    mip_level: int = 0
    #:
    origin: tuple[int, int, int] | Origin3DStruct | None = None
    #: :obj:`enums.TextureAspect <wgpu.enums.TextureAspect>`
    aspect: enums.TextureAspectEnum = "all"
    #:
    color_space: str = "srgb"
    #:
    premultiplied_alpha: bool = False


CopyExternalImageDestInfoStruct = CopyExternalImageDestInfo | dict


@dataclass(kw_only=True)
class CopyExternalImageSourceInfo(Struct):
    #:
    source: ArrayLike | CanvasLike | object
    #:
    origin: tuple[int, int] | Origin2DStruct | None = None
    #:
    flip_y: bool = False


CopyExternalImageSourceInfoStruct = CopyExternalImageSourceInfo | dict


@dataclass(kw_only=True)
class CommandBufferDescriptor(Struct):
    #:
    label: str = ""


CommandBufferDescriptorStruct = CommandBufferDescriptor | dict


@dataclass(kw_only=True)
class CommandEncoderDescriptor(Struct):
    #:
    label: str = ""


CommandEncoderDescriptorStruct = CommandEncoderDescriptor | dict


@dataclass(kw_only=True)
class ComputePassTimestampWrites(Struct):
    #:
    query_set: classes.GPUQuerySet
    #:
    beginning_of_pass_write_index: int | None = None
    #:
    end_of_pass_write_index: int | None = None


ComputePassTimestampWritesStruct = ComputePassTimestampWrites | dict


@dataclass(kw_only=True)
class ComputePassDescriptor(Struct):
    #:
    label: str = ""
    #:
    timestamp_writes: ComputePassTimestampWritesStruct | None = None


ComputePassDescriptorStruct = ComputePassDescriptor | dict


@dataclass(kw_only=True)
class RenderPassTimestampWrites(Struct):
    #:
    query_set: classes.GPUQuerySet
    #:
    beginning_of_pass_write_index: int | None = None
    #:
    end_of_pass_write_index: int | None = None


RenderPassTimestampWritesStruct = RenderPassTimestampWrites | dict


@dataclass(kw_only=True)
class RenderPassDescriptor(Struct):
    #:
    label: str = ""
    #:
    color_attachments: list[RenderPassColorAttachmentStruct]
    #:
    depth_stencil_attachment: RenderPassDepthStencilAttachmentStruct | None = None
    #:
    occlusion_query_set: classes.GPUQuerySet | None = None
    #:
    timestamp_writes: RenderPassTimestampWritesStruct | None = None
    #:
    max_draw_count: int = 50000000


RenderPassDescriptorStruct = RenderPassDescriptor | dict


@dataclass(kw_only=True)
class RenderPassColorAttachment(Struct):
    #:
    view: classes.GPUTexture | classes.GPUTextureView
    #:
    depth_slice: int | None = None
    #:
    resolve_target: classes.GPUTexture | classes.GPUTextureView | None = None
    #:
    clear_value: tuple[float, float, float, float] | ColorStruct | None = None
    #: :obj:`enums.LoadOp <wgpu.enums.LoadOp>`
    load_op: enums.LoadOpEnum
    #: :obj:`enums.StoreOp <wgpu.enums.StoreOp>`
    store_op: enums.StoreOpEnum


RenderPassColorAttachmentStruct = RenderPassColorAttachment | dict


@dataclass(kw_only=True)
class RenderPassDepthStencilAttachment(Struct):
    #:
    view: classes.GPUTexture | classes.GPUTextureView
    #:
    depth_clear_value: float | None = None
    #: :obj:`enums.LoadOp <wgpu.enums.LoadOp>`
    depth_load_op: enums.LoadOpEnum | None = None
    #: :obj:`enums.StoreOp <wgpu.enums.StoreOp>`
    depth_store_op: enums.StoreOpEnum | None = None
    #:
    depth_read_only: bool = False
    #:
    stencil_clear_value: int = 0
    #: :obj:`enums.LoadOp <wgpu.enums.LoadOp>`
    stencil_load_op: enums.LoadOpEnum | None = None
    #: :obj:`enums.StoreOp <wgpu.enums.StoreOp>`
    stencil_store_op: enums.StoreOpEnum | None = None
    #:
    stencil_read_only: bool = False


RenderPassDepthStencilAttachmentStruct = RenderPassDepthStencilAttachment | dict


@dataclass(kw_only=True)
class RenderPassLayout(Struct):
    #:
    label: str = ""
    #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    color_formats: list[enums.TextureFormatEnum]
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    depth_stencil_format: enums.TextureFormatEnum | None = None
    #:
    sample_count: int = 1


RenderPassLayoutStruct = RenderPassLayout | dict


@dataclass(kw_only=True)
class RenderBundleDescriptor(Struct):
    #:
    label: str = ""


RenderBundleDescriptorStruct = RenderBundleDescriptor | dict


@dataclass(kw_only=True)
class RenderBundleEncoderDescriptor(Struct):
    #:
    label: str = ""
    #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    color_formats: list[enums.TextureFormatEnum]
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    depth_stencil_format: enums.TextureFormatEnum | None = None
    #:
    sample_count: int = 1
    #:
    depth_read_only: bool = False
    #:
    stencil_read_only: bool = False


RenderBundleEncoderDescriptorStruct = RenderBundleEncoderDescriptor | dict


@dataclass(kw_only=True)
class QueueDescriptor(Struct):
    #:
    label: str = ""


QueueDescriptorStruct = QueueDescriptor | dict


@dataclass(kw_only=True)
class QuerySetDescriptor(Struct):
    #:
    label: str = ""
    #: :obj:`enums.QueryType <wgpu.enums.QueryType>`
    type: enums.QueryTypeEnum
    #:
    count: int


QuerySetDescriptorStruct = QuerySetDescriptor | dict


@dataclass(kw_only=True)
class CanvasToneMapping(Struct):
    #: :obj:`enums.CanvasToneMappingMode <wgpu.enums.CanvasToneMappingMode>`
    mode: enums.CanvasToneMappingModeEnum = "standard"


CanvasToneMappingStruct = CanvasToneMapping | dict


@dataclass(kw_only=True)
class CanvasConfiguration(Struct):
    #:
    device: classes.GPUDevice
    #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    format: enums.TextureFormatEnum
    #: :obj:`flags.TextureUsage <wgpu.flags.TextureUsage>`
    usage: flags.TextureUsageFlags = 0x10
    #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    view_formats: list[enums.TextureFormatEnum] | None = None
    #:
    color_space: str = "srgb"
    #:
    tone_mapping: CanvasToneMappingStruct | None = None
    #: :obj:`enums.CanvasAlphaMode <wgpu.enums.CanvasAlphaMode>`
    alpha_mode: enums.CanvasAlphaModeEnum = "opaque"


CanvasConfigurationStruct = CanvasConfiguration | dict


@dataclass(kw_only=True)
class UncapturedErrorEventInit(Struct):
    #:
    error: classes.GPUError


UncapturedErrorEventInitStruct = UncapturedErrorEventInit | dict


@dataclass(kw_only=True)
class Color(Struct):
    #:
    r: float
    #:
    g: float
    #:
    b: float
    #:
    a: float


ColorStruct = Color | dict


@dataclass(kw_only=True)
class Origin2D(Struct):
    #:
    x: int = 0
    #:
    y: int = 0


Origin2DStruct = Origin2D | dict


@dataclass(kw_only=True)
class Origin3D(Struct):
    #:
    x: int = 0
    #:
    y: int = 0
    #:
    z: int = 0


Origin3DStruct = Origin3D | dict


@dataclass(kw_only=True)
class Extent3D(Struct):
    #:
    width: int
    #:
    height: int = 1
    #:
    depth_or_array_layers: int = 1


Extent3DStruct = Extent3D | dict
