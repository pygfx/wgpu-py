"""
These structs are defined in ``wgpu.structs``.

The structs in wgpu-py are represented as Python dictionaries.
Fields that have default values (as indicated below) may be omitted.
"""

# Allow using class names in type annotations, without Ruff triggering F821
from __future__ import annotations

from typing import TypedDict
from ._coreutils import ArrayLike
from . import _classes as classes
from . import flags
from . import enums


_use_sphinx_repr = False


class Struct:
    def __init__(self, name, **kwargs):
        self._name = name
        for key, val in kwargs.items():
            setattr(self, key, val)

    def __iter__(self):
        return iter([key for key in dir(self) if not key.startswith("_")])

    def __repr__(self):
        if _use_sphinx_repr:  # no-cover
            return ""
        options = ", ".join(f"'{x}'" for x in self)
        return f"<wgpu.{self._name} struct with fields: {options}>"


# CODE BELOW THIS POINT IS AUTOGENERATED - DO NOT EDIT


# There are 60 structs

__all__ = [
    "BindGroupDescriptor",
    "BindGroupEntry",
    "BindGroupLayoutDescriptor",
    "BindGroupLayoutEntry",
    "BlendComponent",
    "BlendState",
    "BufferBinding",
    "BufferBindingLayout",
    "BufferDescriptor",
    "CanvasConfiguration",
    "CanvasToneMapping",
    "Color",
    "ColorTargetState",
    "CommandBufferDescriptor",
    "CommandEncoderDescriptor",
    "ComputePassDescriptor",
    "ComputePassTimestampWrites",
    "ComputePipelineDescriptor",
    "CopyExternalImageDestInfo",
    "CopyExternalImageSourceInfo",
    "DepthStencilState",
    "DeviceDescriptor",
    "Extent3D",
    "ExternalTextureBindingLayout",
    "ExternalTextureDescriptor",
    "FragmentState",
    "MultisampleState",
    "Origin2D",
    "Origin3D",
    "PipelineErrorInit",
    "PipelineLayoutDescriptor",
    "PrimitiveState",
    "ProgrammableStage",
    "QuerySetDescriptor",
    "QueueDescriptor",
    "RenderBundleDescriptor",
    "RenderBundleEncoderDescriptor",
    "RenderPassColorAttachment",
    "RenderPassDepthStencilAttachment",
    "RenderPassDescriptor",
    "RenderPassLayout",
    "RenderPassTimestampWrites",
    "RenderPipelineDescriptor",
    "RequestAdapterOptions",
    "SamplerBindingLayout",
    "SamplerDescriptor",
    "ShaderModuleCompilationHint",
    "ShaderModuleDescriptor",
    "StencilFaceState",
    "StorageTextureBindingLayout",
    "TexelCopyBufferInfo",
    "TexelCopyBufferLayout",
    "TexelCopyTextureInfo",
    "TextureBindingLayout",
    "TextureDescriptor",
    "TextureViewDescriptor",
    "UncapturedErrorEventInit",
    "VertexAttribute",
    "VertexBufferLayout",
    "VertexState",
]


class RequestAdapterOptions(TypedDict, total=False):
    feature_level: str  #:
    power_preference: (
        enums.PowerPreferenceEnum
    )  #: :obj:`enums.PowerPreference <wgpu.enums.PowerPreference>`
    force_fallback_adapter: bool  #:
    xr_compatible: bool  #:


class DeviceDescriptor(TypedDict, total=False):
    label: str  #:
    required_features: list[
        enums.FeatureNameEnum
    ]  #: list[:obj:`enums.FeatureName <wgpu.enums.FeatureName>`]
    required_limits: dict[str, None | int]  #:
    default_queue: QueueDescriptor  #:


class BufferDescriptor(TypedDict, total=False):
    label: str  #:
    size: int  #:
    usage: flags.BufferUsageFlags  #: :obj:`flags.BufferUsage <wgpu.flags.BufferUsage>`
    mapped_at_creation: bool  #:


class TextureDescriptor(TypedDict, total=False):
    label: str  #:
    size: tuple[int, int, int] | Extent3D  #:
    mip_level_count: int  #:
    sample_count: int  #:
    dimension: (
        enums.TextureDimensionEnum
    )  #: :obj:`enums.TextureDimension <wgpu.enums.TextureDimension>`
    format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    usage: (
        flags.TextureUsageFlags
    )  #: :obj:`flags.TextureUsage <wgpu.flags.TextureUsage>`
    view_formats: list[
        enums.TextureFormatEnum
    ]  #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]


class TextureViewDescriptor(TypedDict, total=False):
    label: str  #:
    format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    dimension: (
        enums.TextureViewDimensionEnum
    )  #: :obj:`enums.TextureViewDimension <wgpu.enums.TextureViewDimension>`
    usage: (
        flags.TextureUsageFlags
    )  #: :obj:`flags.TextureUsage <wgpu.flags.TextureUsage>`
    aspect: (
        enums.TextureAspectEnum
    )  #: :obj:`enums.TextureAspect <wgpu.enums.TextureAspect>`
    base_mip_level: int  #:
    mip_level_count: int  #:
    base_array_layer: int  #:
    array_layer_count: int  #:


class ExternalTextureDescriptor(TypedDict, total=False):
    label: str  #:
    source: ArrayLike | object  #:
    color_space: str  #:


class SamplerDescriptor(TypedDict, total=False):
    label: str  #:
    address_mode_u: (
        enums.AddressModeEnum
    )  #: :obj:`enums.AddressMode <wgpu.enums.AddressMode>`
    address_mode_v: (
        enums.AddressModeEnum
    )  #: :obj:`enums.AddressMode <wgpu.enums.AddressMode>`
    address_mode_w: (
        enums.AddressModeEnum
    )  #: :obj:`enums.AddressMode <wgpu.enums.AddressMode>`
    mag_filter: enums.FilterModeEnum  #: :obj:`enums.FilterMode <wgpu.enums.FilterMode>`
    min_filter: enums.FilterModeEnum  #: :obj:`enums.FilterMode <wgpu.enums.FilterMode>`
    mipmap_filter: (
        enums.MipmapFilterModeEnum
    )  #: :obj:`enums.MipmapFilterMode <wgpu.enums.MipmapFilterMode>`
    lod_min_clamp: float  #:
    lod_max_clamp: float  #:
    compare: (
        enums.CompareFunctionEnum
    )  #: :obj:`enums.CompareFunction <wgpu.enums.CompareFunction>`
    max_anisotropy: int  #:


class BindGroupLayoutDescriptor(TypedDict, total=False):
    label: str  #:
    entries: list[BindGroupLayoutEntry]  #:


class BindGroupLayoutEntry(TypedDict, total=False):
    binding: int  #:
    visibility: (
        flags.ShaderStageFlags
    )  #: :obj:`flags.ShaderStage <wgpu.flags.ShaderStage>`
    buffer: BufferBindingLayout  #:
    sampler: SamplerBindingLayout  #:
    texture: TextureBindingLayout  #:
    storage_texture: StorageTextureBindingLayout  #:
    external_texture: ExternalTextureBindingLayout  #:


class BufferBindingLayout(TypedDict, total=False):
    type: (
        enums.BufferBindingTypeEnum
    )  #: :obj:`enums.BufferBindingType <wgpu.enums.BufferBindingType>`
    has_dynamic_offset: bool  #:
    min_binding_size: int  #:


class SamplerBindingLayout(TypedDict, total=False):
    type: (
        enums.SamplerBindingTypeEnum
    )  #: :obj:`enums.SamplerBindingType <wgpu.enums.SamplerBindingType>`


class TextureBindingLayout(TypedDict, total=False):
    sample_type: (
        enums.TextureSampleTypeEnum
    )  #: :obj:`enums.TextureSampleType <wgpu.enums.TextureSampleType>`
    view_dimension: (
        enums.TextureViewDimensionEnum
    )  #: :obj:`enums.TextureViewDimension <wgpu.enums.TextureViewDimension>`
    multisampled: bool  #:


class StorageTextureBindingLayout(TypedDict, total=False):
    access: (
        enums.StorageTextureAccessEnum
    )  #: :obj:`enums.StorageTextureAccess <wgpu.enums.StorageTextureAccess>`
    format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    view_dimension: (
        enums.TextureViewDimensionEnum
    )  #: :obj:`enums.TextureViewDimension <wgpu.enums.TextureViewDimension>`


class ExternalTextureBindingLayout(TypedDict, total=False):
    pass


class BindGroupDescriptor(TypedDict, total=False):
    label: str  #:
    layout: classes.GPUBindGroupLayout  #:
    entries: list[BindGroupEntry]  #:


class BindGroupEntry(TypedDict, total=False):
    binding: int  #:
    resource: (
        classes.GPUBuffer
        | classes.GPUSampler
        | classes.GPUTexture
        | classes.GPUTextureView
        | object
        | BufferBinding
    )  #:


class BufferBinding(TypedDict, total=False):
    buffer: classes.GPUBuffer  #:
    offset: int  #:
    size: int  #:


class PipelineLayoutDescriptor(TypedDict, total=False):
    label: str  #:
    bind_group_layouts: list[classes.GPUBindGroupLayout]  #:


class ShaderModuleDescriptor(TypedDict, total=False):
    label: str  #:
    code: str  #:
    compilation_hints: list[ShaderModuleCompilationHint]  #:


class ShaderModuleCompilationHint(TypedDict, total=False):
    entry_point: str  #:
    layout: (
        classes.GPUPipelineLayout | enums.AutoLayoutModeEnum
    )  #: classes.:class:`GPUPipelineLayout <wgpu.GPUPipelineLayout>` | :obj:`enums.AutoLayoutMode <wgpu.enums.AutoLayoutMode>`


class PipelineErrorInit(TypedDict, total=False):
    reason: (
        enums.PipelineErrorReasonEnum
    )  #: :obj:`enums.PipelineErrorReason <wgpu.enums.PipelineErrorReason>`


class ProgrammableStage(TypedDict, total=False):
    module: classes.GPUShaderModule  #:
    entry_point: str  #:
    constants: dict[str, float]  #:


class ComputePipelineDescriptor(TypedDict, total=False):
    label: str  #:
    layout: (
        classes.GPUPipelineLayout | enums.AutoLayoutModeEnum
    )  #: classes.:class:`GPUPipelineLayout <wgpu.GPUPipelineLayout>` | :obj:`enums.AutoLayoutMode <wgpu.enums.AutoLayoutMode>`
    compute: ProgrammableStage  #:


class RenderPipelineDescriptor(TypedDict, total=False):
    label: str  #:
    layout: (
        classes.GPUPipelineLayout | enums.AutoLayoutModeEnum
    )  #: classes.:class:`GPUPipelineLayout <wgpu.GPUPipelineLayout>` | :obj:`enums.AutoLayoutMode <wgpu.enums.AutoLayoutMode>`
    vertex: VertexState  #:
    primitive: PrimitiveState  #:
    depth_stencil: DepthStencilState  #:
    multisample: MultisampleState  #:
    fragment: FragmentState  #:


class PrimitiveState(TypedDict, total=False):
    topology: (
        enums.PrimitiveTopologyEnum
    )  #: :obj:`enums.PrimitiveTopology <wgpu.enums.PrimitiveTopology>`
    strip_index_format: (
        enums.IndexFormatEnum
    )  #: :obj:`enums.IndexFormat <wgpu.enums.IndexFormat>`
    front_face: enums.FrontFaceEnum  #: :obj:`enums.FrontFace <wgpu.enums.FrontFace>`
    cull_mode: enums.CullModeEnum  #: :obj:`enums.CullMode <wgpu.enums.CullMode>`
    unclipped_depth: bool  #:


class MultisampleState(TypedDict, total=False):
    count: int  #:
    mask: int  #:
    alpha_to_coverage_enabled: bool  #:


class FragmentState(TypedDict, total=False):
    module: classes.GPUShaderModule  #:
    entry_point: str  #:
    constants: dict[str, float]  #:
    targets: list[ColorTargetState]  #:


class ColorTargetState(TypedDict, total=False):
    format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    blend: BlendState  #:
    write_mask: (
        flags.ColorWriteFlags
    )  #: :obj:`flags.ColorWrite <wgpu.flags.ColorWrite>`


class BlendState(TypedDict, total=False):
    color: BlendComponent  #:
    alpha: BlendComponent  #:


class BlendComponent(TypedDict, total=False):
    operation: (
        enums.BlendOperationEnum
    )  #: :obj:`enums.BlendOperation <wgpu.enums.BlendOperation>`
    src_factor: (
        enums.BlendFactorEnum
    )  #: :obj:`enums.BlendFactor <wgpu.enums.BlendFactor>`
    dst_factor: (
        enums.BlendFactorEnum
    )  #: :obj:`enums.BlendFactor <wgpu.enums.BlendFactor>`


class DepthStencilState(TypedDict, total=False):
    format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    depth_write_enabled: bool  #:
    depth_compare: (
        enums.CompareFunctionEnum
    )  #: :obj:`enums.CompareFunction <wgpu.enums.CompareFunction>`
    stencil_front: StencilFaceState  #:
    stencil_back: StencilFaceState  #:
    stencil_read_mask: int  #:
    stencil_write_mask: int  #:
    depth_bias: int  #:
    depth_bias_slope_scale: float  #:
    depth_bias_clamp: float  #:


class StencilFaceState(TypedDict, total=False):
    compare: (
        enums.CompareFunctionEnum
    )  #: :obj:`enums.CompareFunction <wgpu.enums.CompareFunction>`
    fail_op: (
        enums.StencilOperationEnum
    )  #: :obj:`enums.StencilOperation <wgpu.enums.StencilOperation>`
    depth_fail_op: (
        enums.StencilOperationEnum
    )  #: :obj:`enums.StencilOperation <wgpu.enums.StencilOperation>`
    pass_op: (
        enums.StencilOperationEnum
    )  #: :obj:`enums.StencilOperation <wgpu.enums.StencilOperation>`


class VertexState(TypedDict, total=False):
    module: classes.GPUShaderModule  #:
    entry_point: str  #:
    constants: dict[str, float]  #:
    buffers: list[VertexBufferLayout]  #:


class VertexBufferLayout(TypedDict, total=False):
    array_stride: int  #:
    step_mode: (
        enums.VertexStepModeEnum
    )  #: :obj:`enums.VertexStepMode <wgpu.enums.VertexStepMode>`
    attributes: list[VertexAttribute]  #:


class VertexAttribute(TypedDict, total=False):
    format: (
        enums.VertexFormatEnum
    )  #: :obj:`enums.VertexFormat <wgpu.enums.VertexFormat>`
    offset: int  #:
    shader_location: int  #:


class TexelCopyBufferLayout(TypedDict, total=False):
    offset: int  #:
    bytes_per_row: int  #:
    rows_per_image: int  #:


class TexelCopyBufferInfo(TypedDict, total=False):
    offset: int  #:
    bytes_per_row: int  #:
    rows_per_image: int  #:
    buffer: classes.GPUBuffer  #:


class TexelCopyTextureInfo(TypedDict, total=False):
    texture: classes.GPUTexture  #:
    mip_level: int  #:
    origin: tuple[int, int, int] | Origin3D  #:
    aspect: (
        enums.TextureAspectEnum
    )  #: :obj:`enums.TextureAspect <wgpu.enums.TextureAspect>`


class CopyExternalImageDestInfo(TypedDict, total=False):
    texture: classes.GPUTexture  #:
    mip_level: int  #:
    origin: tuple[int, int, int] | Origin3D  #:
    aspect: (
        enums.TextureAspectEnum
    )  #: :obj:`enums.TextureAspect <wgpu.enums.TextureAspect>`
    color_space: str  #:
    premultiplied_alpha: bool  #:


class CopyExternalImageSourceInfo(TypedDict, total=False):
    source: ArrayLike | CanvasLike | object  #:
    origin: tuple[int, int] | Origin2D  #:
    flip_y: bool  #:


class CommandBufferDescriptor(TypedDict, total=False):
    label: str  #:


class CommandEncoderDescriptor(TypedDict, total=False):
    label: str  #:


class ComputePassTimestampWrites(TypedDict, total=False):
    query_set: classes.GPUQuerySet  #:
    beginning_of_pass_write_index: int  #:
    end_of_pass_write_index: int  #:


class ComputePassDescriptor(TypedDict, total=False):
    label: str  #:
    timestamp_writes: ComputePassTimestampWrites  #:


class RenderPassTimestampWrites(TypedDict, total=False):
    query_set: classes.GPUQuerySet  #:
    beginning_of_pass_write_index: int  #:
    end_of_pass_write_index: int  #:


class RenderPassDescriptor(TypedDict, total=False):
    label: str  #:
    color_attachments: list[RenderPassColorAttachment]  #:
    depth_stencil_attachment: RenderPassDepthStencilAttachment  #:
    occlusion_query_set: classes.GPUQuerySet  #:
    timestamp_writes: RenderPassTimestampWrites  #:
    max_draw_count: int  #:


class RenderPassColorAttachment(TypedDict, total=False):
    view: classes.GPUTexture | classes.GPUTextureView  #:
    depth_slice: int  #:
    resolve_target: classes.GPUTexture | classes.GPUTextureView  #:
    clear_value: tuple[float, float, float, float] | Color  #:
    load_op: enums.LoadOpEnum  #: :obj:`enums.LoadOp <wgpu.enums.LoadOp>`
    store_op: enums.StoreOpEnum  #: :obj:`enums.StoreOp <wgpu.enums.StoreOp>`


class RenderPassDepthStencilAttachment(TypedDict, total=False):
    view: classes.GPUTexture | classes.GPUTextureView  #:
    depth_clear_value: float  #:
    depth_load_op: enums.LoadOpEnum  #: :obj:`enums.LoadOp <wgpu.enums.LoadOp>`
    depth_store_op: enums.StoreOpEnum  #: :obj:`enums.StoreOp <wgpu.enums.StoreOp>`
    depth_read_only: bool  #:
    stencil_clear_value: int  #:
    stencil_load_op: enums.LoadOpEnum  #: :obj:`enums.LoadOp <wgpu.enums.LoadOp>`
    stencil_store_op: enums.StoreOpEnum  #: :obj:`enums.StoreOp <wgpu.enums.StoreOp>`
    stencil_read_only: bool  #:


class RenderPassLayout(TypedDict, total=False):
    label: str  #:
    color_formats: list[
        enums.TextureFormatEnum
    ]  #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    depth_stencil_format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    sample_count: int  #:


class RenderBundleDescriptor(TypedDict, total=False):
    label: str  #:


class RenderBundleEncoderDescriptor(TypedDict, total=False):
    label: str  #:
    color_formats: list[
        enums.TextureFormatEnum
    ]  #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    depth_stencil_format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    sample_count: int  #:
    depth_read_only: bool  #:
    stencil_read_only: bool  #:


class QueueDescriptor(TypedDict, total=False):
    label: str  #:


class QuerySetDescriptor(TypedDict, total=False):
    label: str  #:
    type: enums.QueryTypeEnum  #: :obj:`enums.QueryType <wgpu.enums.QueryType>`
    count: int  #:


class CanvasToneMapping(TypedDict, total=False):
    mode: (
        enums.CanvasToneMappingModeEnum
    )  #: :obj:`enums.CanvasToneMappingMode <wgpu.enums.CanvasToneMappingMode>`


class CanvasConfiguration(TypedDict, total=False):
    device: classes.GPUDevice  #:
    format: (
        enums.TextureFormatEnum
    )  #: :obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`
    usage: (
        flags.TextureUsageFlags
    )  #: :obj:`flags.TextureUsage <wgpu.flags.TextureUsage>`
    view_formats: list[
        enums.TextureFormatEnum
    ]  #: list[:obj:`enums.TextureFormat <wgpu.enums.TextureFormat>`]
    color_space: str  #:
    tone_mapping: CanvasToneMapping  #:
    alpha_mode: (
        enums.CanvasAlphaModeEnum
    )  #: :obj:`enums.CanvasAlphaMode <wgpu.enums.CanvasAlphaMode>`


class UncapturedErrorEventInit(TypedDict, total=False):
    error: classes.GPUError  #:


class Color(TypedDict, total=False):
    r: float  #:
    g: float  #:
    b: float  #:
    a: float  #:


class Origin2D(TypedDict, total=False):
    x: int  #:
    y: int  #:


class Origin3D(TypedDict, total=False):
    x: int  #:
    y: int  #:
    z: int  #:


class Extent3D(TypedDict, total=False):
    width: int  #:
    height: int  #:
    depth_or_array_layers: int  #:
